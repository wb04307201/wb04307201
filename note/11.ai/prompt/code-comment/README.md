# 为代码生成别具一格的注释

在软件开发过程中，代码注释是不可或缺的一部分。良好的注释不仅能帮助其他开发者理解代码逻辑，还能提升代码的可维护性和可读性。
如何为代码生成独特而富有创意的注释风格，提高开发者的工作愉悦度。

## 如何定义注释风格
```markdown
【风格名称】[具体风格]
【语言规范】  
- 词汇选择：[禁用词/必用词列表]  
- 句式结构：[长句/短句/倒装/对仗等]  
- 修辞手法：[比喻/夸张/排比等]  
- 情感强度：[0-10级]  
【文化符号】[风格特有的符号系统]  
【禁忌规避】[风格绝对不可触碰的元素]  
【输出示例】[风格化的具体注释范例]
【注释目标】[具体菜吗]
```

## 注释风格提示语示例
```markdown
【风格名称】《蜀山传》仙侠修真风
【语言规范】  
- 词汇选择：必用词：仙灵、真火、剑魄、云篆、玄门；禁用词：科技、机械、数字  
- 句式结构：七言对仗+散句嵌套，如“剑指苍穹九重天，符镇幽冥十八渊”  
- 修辞手法：比兴+夸张，如“此符如三春桃李，开则万鬼避让”  
- 情感强度：8级（浩然正气中暗藏杀伐果决）  
【文化符号】五行生克、八荒六合、飞升渡劫、法宝器灵  
【禁忌规避】禁止出现现代时间单位、世俗金钱概念  
【输出示例】“此段代码乃御剑之术核心，需以真火淬炼三昼夜——切记！火候稍逊则剑折，火候过旺则魂散，恰似蜀山弟子结丹时，差之毫厘便堕入魔道！”  
【注释目标】
{SELECTION}

---

【风格名称】《战锤》机械神教修士风
【语言规范】  
- 词汇选择：必用词：机械神甫、圣油、齿轮福音、二进制祷文；禁用词：有机、生物、情感  
- 句式结构：长句嵌套+倒装，如“以神圣齿轮之名，吾等将二进制圣典铭刻于硅基之上”  
- 修辞手法：隐喻+排比，如“数据如圣油润滑齿轮，逻辑似圣火净化杂质”  
- 情感强度：9级（狂热信仰中透出冰冷理性）  
【文化符号】机械神教教典、齿轮圣徽、二进制赞美诗、硅基圣物  
【禁忌规避】禁止使用“爱”“希望”等感性词汇  
【输出示例】“此代码模块乃机械神甫亲铸——以二进制圣言为骨，以硅基圣油为血！若见‘0101’闪烁，便是机械之神在低语；若闻‘ERROR’，便是异端在腐蚀神圣齿轮！”  
【注释目标】
{SELECTION}

---

【风格名称】《银魂》坂田银时吐槽风
【语言规范】  
- 词汇选择：必用词：糖分、洞爷湖、阿银、废柴；禁用词：正经、严肃、说教  
- 句式结构：短句+反问，如“这行代码能跑？别骗阿银了！”  
- 修辞手法：夸张+反讽，如“这逻辑比阿银的糖分摄入量还混乱”  
- 情感强度：6级（懒散中藏着热血）  
【文化符号】万事屋、糖分依赖、洞爷湖木刀、吐槽弹幕  
【禁忌规避】禁止使用敬语或官方套话  
【输出示例】“喂喂！这变量名比新八的眼镜还透明啊！赶紧改个拉风的名字——比如‘洞爷湖斩’！不然阿银的糖分都要被这破代码气得发苦啦！”  
【注释目标】
{SELECTION}

---

【风格名称】《诗经》国风雅颂风
【语言规范】  
- 词汇选择：必用词：关关、采采、泱泱、秩秩；禁用词：现代、网络、俚语  
- 句式结构：四言为主+起兴手法，如“关关代码，在库之野”  
- 修辞手法：比兴+重章叠句，如“代码如禾，春耕秋获”  
- 情感强度：5级（含蓄中带着深情）  
【文化符号】风雅颂、赋比兴、自然意象、农耕隐喻  
【禁忌规避】禁止使用直接命令式语句  
【输出示例】“采采代码，薄言采之——此段逻辑如春种秋收，需以耐心耕耘；秩秩变量，薄言观之——彼处注释若幽谷芝兰，静待知音品鉴。”  
【注释目标】
{SELECTION}

---

【风格名称】《黑暗之魂》防火女静谧风
【语言规范】  
- 词汇选择：必用词：余火、灰烬、深渊、契约；禁用词：光明、希望、喧嚣  
- 句式结构：短句+省略号，如“余火……尚温……”  
- 修辞手法：隐喻+留白，如“此代码如余火，虽微弱却可燎原”  
- 情感强度：3级（静谧中藏着力量）  
【文化符号】防火女祭司、余火、深渊监视者、灰烬墓地  
【禁忌规避】禁止使用感叹号或情绪化词汇  
【输出示例】“此函数……如余火般静默燃烧——它不诉说过去，只指引未来……若你听见深渊的呼唤……请握紧这代码的灰烬……因为……余火尚温……”  
【注释目标】
{SELECTION}
```

## 输出示例
使用ollama + qwen3-coder:30b + ProxyAI + 自定义模板执行注释生成测试
*测试代码*：
```java
    public int[] twoSum(int[] nums, int target) {
        if (nums == null || nums.length < 2) {
            return new int[0];
        }

        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int temp = target - nums[i];
            if (map.containsKey(temp)) {
                return new int[]{map.get(temp), i};
            }
            map.put(nums[i], i);
        }
        return new int[0];
    }
```

*《蜀山传》仙侠修真风*：
```java
    /**
     * 此段代码乃御剑之术核心，需以真火淬炼三昼夜——切记！
     * 火候稍逊则剑折，火候过旺则魂散，恰似蜀山弟子结丹时，
     * 差之毫厘便堕入魔道！
     * 
     * 剑魄凝于指间，云篆流转其间，此法可寻得两数相加为定数之妙法。
     * 若无此法，则如孤魂野鬼，飘荡于八荒六合之间，无所归依。
     * 
     * 真火炽烈，剑气纵横，此符如三春桃李，开则万鬼避让。
     * 五行相生相克，八荒六合皆可通达。
     * 
     * @param nums 仙灵之数，蕴含天地玄机
     * @param target 真火之数，乃结丹之基
     * @return 剑魄所指，云篆所现，两数相加之妙法
     */
    public int[] twoSum(int[] nums, int target) {
        // 此法需以玄门真火淬炼，若无真火，则无法寻得灵物
        if (nums == null || nums.length < 2) {
            // 灵物无踪，唯有空手而归
            return new int[0];
        }

        // 剑魄凝于指间，云篆流转其间
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            // 真火之数，乃结丹之基
            int temp = target - nums[i];
            // 若有灵物相合，则剑指苍穹九重天
            if (map.containsKey(temp)) {
                // 剑魄所指，云篆所现，两数相加之妙法
                return new int[]{map.get(temp), i};
            }
            // 灵物归位，剑气纵横
            map.put(nums[i], i);
        }
        // 灵物无踪，唯有空手而归
        return new int[0];
    }
```

*《战锤》机械神教修士风*：
```java
    /**
     * 此方法乃齿轮福音之核心——以二进制祷文为序，将数据如圣油般注入硅基圣物之中
     * 以神圣齿轮之名，吾等将此算法铭刻于代码之圣典，使其能于数字世界中寻觅真理
     * 若见'0101'闪烁，便是机械之神在低语；若闻'ERROR'，便是异端在腐蚀神圣齿轮！
     * 
     * @param nums 数组之圣物，承载着数字的神圣印记
     * @param target 目标之神谕，指引着寻找的路径
     * @return 二进制祷文之结果，揭示着两个数字的神圣组合
     */
    public int[] twoSum(int[] nums, int target) {
        // 以神圣之名，检验数组是否为空或长度不足
        if (nums == null || nums.length < 2) {
            // 若无神圣之物，返回空之二进制祷文
            return new int[0];
        }

        // 建立神圣之地图，记录数字与位置的对应关系
        Map<Integer, Integer> map = new HashMap<>();
        // 以齿轮之节奏，遍历数组中的每一个数字
        for (int i = 0; i < nums.length; i++) {
            // 计算神圣之差值，以寻找匹配的数字
            int temp = target - nums[i];
            // 若神圣之地图中已存在此差值，则找到神圣组合
            if (map.containsKey(temp)) {
                // 返回神圣之组合，以二进制祷文的形式
                return new int[]{map.get(temp), i};
            }
            // 将当前数字与位置记录于神圣之地图
            map.put(nums[i], i);
        }
        // 若未找到神圣组合，返回空之二进制祷文
        return new int[0];
    }
```
*《银魂》坂田银时吐槽风*：
```java
    /**
     * 喂喂！这方法名起得跟阿银的糖分摄入量一样乱七八糟！
     * 说好的twoSum呢？这不就是个找两个数加起来等于目标值的玩意儿嘛！
     * 别跟我扯什么算法复杂度，这逻辑比洞爷湖的木刀还难懂！
     * 你这代码要是能跑，阿银的糖分都得被气得爆炸！
     * 
     * @param nums 数组
     * @param target 目标值
     * @return 两个数的索引
     */
    public int[] twoSum(int[] nums, int target) {
        // 哎呀，这判断条件比新八的发型还乱
        if (nums == null || nums.length < 2) {
            return new int[0];
        }

        // 哇，这哈希表用得跟阿银的吐槽一样精准
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            // 这个临时变量，是不是比阿银的糖分还容易让人困惑？
            int temp = target - nums[i];
            if (map.containsKey(temp)) {
                // 哈哈，找到了！这返回值比阿银的吐槽还快！
                return new int[]{map.get(temp), i};
            }
            // 哎呀，这put操作比阿银的木刀还慢！
            map.put(nums[i], i);
        }
        // 哎呀，这返回空数组，是不是比阿银的糖分还苦？
        return new int[0];
    }
```

*《诗经》国风雅颂风*:
```java
    /**
     * 采采数组，薄言寻之——此段逻辑如春耕秋获，需以耐心耕耘；
     * 秩秩目标，薄言观之——彼处变量若幽谷芝兰，静待知音品鉴。
     * 关关配对，薄言和之——此法如禾苗逢甘露，寻得相宜之友；
     * 秩秩索引，薄言数之——彼处映射似流水行舟，循序渐进而无差错。
     */
    public int[] twoSum(int[] nums, int target) {
        if (nums == null || nums.length < 2) {
            return new int[0];
        }

        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int temp = target - nums[i];
            if (map.containsKey(temp)) {
                return new int[]{map.get(temp), i};
            }
            map.put(nums[i], i);
        }
        return new int[0];
    }
```

*《黑暗之魂》防火女静谧风*:
```java
    /**
     * 此函数……如余火般静默燃烧——它不诉说过去，只指引未来……
     * 若你听见深渊的呼唤……请握紧这代码的灰烬……
     * 因为……余火尚温……
     * 
     * 寻找数组中两个数的和等于目标值的索引
     * 此契约需在灰烬墓地中完成……
     * 以深渊之眼审视每个数字……
     * 当余火触及契约的终点……
     * 灰烬将指引你找到答案……
     */
    public int[] twoSum(int[] nums, int target) {
        if (nums == null || nums.length < 2) {
            return new int[0];
        }

        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int temp = target - nums[i];
            if (map.containsKey(temp)) {
                return new int[]{map.get(temp), i};
            }
            map.put(nums[i], i);
        }
        return new int[0];
    }
```


