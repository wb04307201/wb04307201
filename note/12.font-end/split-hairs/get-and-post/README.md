# HTTP 请求中的 GET 和 POST

## 1. 核心用途
- **GET**
    - 用于**请求数据**（从服务器获取资源）。
    - 例如：搜索页面、加载文章、获取 API 数据。
    - 语义上表示“只读”操作，不应修改服务器状态。

- **POST**
    - 用于**提交数据**（向服务器发送数据并创建/更新资源）。
    - 例如：用户登录、表单提交、文件上传。
    - 语义上表示可能修改服务器状态的操作。

---

## 2. 数据传输方式
- **GET**
    - 数据通过 **URL 查询字符串（Query String）** 传递，附加在 URL 后（如 `?key=value&name=test`）。
    - 数据可见于浏览器地址栏、服务器日志、HTTP 请求头。
    - 长度受 URL 限制（通常不超过 2048 字符）。

- **POST**
    - 数据通过 **请求体（Request Body）** 发送，不显示在 URL 中。
    - 数据在 HTTP 请求的 `body` 部分，支持多种格式（如 `application/x-www-form-urlencoded`、`multipart/form-data`、`application/json`）。
    - 理论上无长度限制（实际受服务器配置限制）。

---

## 3. 安全性
- **GET**
    - **不安全**：数据暴露在 URL 中，容易被窃取或篡改（如通过浏览器历史记录、服务器日志）。
    - 适合传输非敏感数据（如搜索关键词）。

- **POST**
    - **相对安全**：数据不在 URL 中，但请求体仍可能被拦截（需配合 HTTPS 加密）。
    - 适合传输敏感数据（如密码、支付信息）。

---

## 4. 缓存与书签
- **GET**
    - 请求可被浏览器缓存、保存为书签或分享（因为 URL 包含完整信息）。
    - 例如：分享一个搜索结果链接。

- **POST**
    - 请求通常不会被缓存或保存为书签（因为数据在请求体中）。
    - 例如：提交表单后无法通过书签复现操作。

---

## 5. 幂等性（Idempotence）
- **GET**
    - 是幂等的：多次重复请求不会改变服务器状态（如多次加载同一页面）。
    - 服务器应确保重复 GET 请求的结果一致。

- **POST**
    - 非幂等的：多次重复提交可能产生副作用（如重复下单、重复评论）。
    - 需由客户端或服务器避免重复操作（如通过 Token 机制）。

---

## 6. HTTP 规范与历史
- **GET**
    - 最早定义的 HTTP 方法之一，设计初衷是简单的数据获取。
    - 支持的 HTTP 版本：HTTP/1.0、HTTP/1.1、HTTP/2、HTTP/3。

- **POST**
    - 用于需要服务器处理数据的场景，如表单提交。
    - 同样支持所有 HTTP 版本，且在 RESTful API 中广泛用于创建资源（如 `POST /users`）。

---

## 7. 其他差异
| **特性**     | **GET**            | **POST**        |
|------------|--------------------|-----------------|
| **浏览器限制**  | 可保存为书签             | 不可保存为书签         |
| **数据类型**   | 仅 ASCII 字符（URL 编码） | 支持二进制数据（如文件上传）  |
| **历史记录**   | 保留在浏览器历史中          | 不保留在历史中         |
| **SEO 友好** | 适合（URL 可被搜索引擎索引）   | 不适合（数据不在 URL 中） |

---

## 何时使用？
- **用 GET**：
    - 获取数据且无需修改服务器状态（如搜索、分页）。
    - 需要缓存或分享链接的场景。

- **用 POST**：
    - 提交数据（如表单、文件上传）。
    - 操作可能改变服务器状态（如创建订单、更新用户信息）。
    - 传输敏感数据（需配合 HTTPS）。

---

## 扩展：其他 HTTP 方法
- **PUT**：更新整个资源（幂等）。
- **PATCH**：部分更新资源（非幂等）。
- **DELETE**：删除资源（幂等）。
- **HEAD**：类似 GET，但只返回响应头（不返回 body）。

理解 GET 和 POST 的差异有助于设计更安全、高效的 Web 应用和 API。