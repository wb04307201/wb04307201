# MySQL的事务隔离机制

MySQL的事务隔离机制是保障数据库并发操作下数据一致性的核心机制，基于ACID（原子性、一致性、隔离性、持久性）原则设计。

## 1. 四大隔离级别（由低到高）
- **读未提交（READ UNCOMMITTED）**
    - 允许事务读取其他未提交的修改，可能引发**脏读**（读到未提交的无效数据）、**不可重复读**（同一事务内多次读取结果不一致）、**幻读**（新增/删除数据导致范围查询结果变化）。
    - 性能最高，但数据一致性最弱，极少使用。

- **读已提交（READ COMMITTED）**
    - 事务只能读取已提交的数据，避免脏读，但**不可重复读**和**幻读**仍可能发生。
    - MySQL通过**MVCC（多版本并发控制）** 实现：读操作使用“快照版本”，写操作使用“当前版本”，其他事务的未提交写操作会被阻塞。
    - 广泛用于OLTP场景（如银行交易）。

- **可重复读（REPEATABLE READ）**
    - **MySQL默认隔离级别**。同一事务内多次读取同一数据范围时，结果保持一致（基于事务启动时的快照），避免不可重复读；通过**间隙锁（Gap Lock）** 防止幻读（如阻止其他事务在扫描范围内插入新记录）。
    - InnoDB通过MVCC+锁机制实现：读操作使用事务开始时的快照，写操作加行锁+间隙锁。
    - 适用于需要数据一致性的场景（如报表统计）。

- **串行化（SERIALIZABLE）**
    - 最高隔离级别，强制事务串行执行，完全避免脏读、不可重复读、幻读，但性能最低。
    - 通过锁住整个表或范围实现，适用于对一致性要求极高的场景（如金融核销）。

## 2. 核心实现原理
- **MVCC（多版本并发控制）**
    - InnoDB为每行数据维护多个版本（通过隐藏列`DB_TRX_ID`记录最后一次修改的事务ID，`DB_ROLL_PTR`指向回滚段）。
    - 读操作根据隔离级别选择快照版本（如可重复读使用事务开始时的版本，读已提交使用最新已提交版本）。
    - 写操作（INSERT/UPDATE/DELETE）会加排他锁（X锁），并生成新版本数据，旧版本通过回滚段保留。

- **锁机制**
    - **行锁（Record Lock）**：锁定索引记录，避免其他事务修改同一行。
    - **间隙锁（Gap Lock）**：锁定索引记录之间的“间隙”，防止幻读（仅可重复读及以上级别使用）。
    - **表锁**：在DDL（如ALTER TABLE）或串行化隔离级别下使用。

- **事务ID与回滚段**
    - 每个事务启动时分配唯一事务ID，修改数据时生成新版本并记录回滚指针，事务提交后旧版本数据保留至无活跃事务引用。

## 3. 并发问题与解决方案
- **脏读**：读未提交可能发生，通过读已提交及以上级别避免。
- **不可重复读**：读已提交可能发生，通过可重复读及以上级别避免（基于快照一致性）。
- **幻读**：可重复读通过间隙锁防止（如`SELECT * FROM t WHERE id BETWEEN 10 AND 20 FOR UPDATE`会锁定10到20的间隙，阻止插入新记录）；串行化通过锁表避免。
- **死锁**：InnoDB自动检测死锁（通过超时或死锁检测），回滚代价最小的事务并抛出错误，需应用重试机制。

## 4. 存储引擎差异
- **InnoDB**：支持所有隔离级别，默认可重复读，通过MVCC+锁实现高并发一致性。
- **MyISAM**：不支持事务和隔离级别，仅表级锁，已逐渐被InnoDB替代。

## 5. 操作实践
- 设置隔离级别：
  ```sql
  SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ; -- 设置当前会话隔离级别
  START TRANSACTION; -- 启动事务（可加WITH CONSISTENT SNAPSHOT获取一致快照）
  ```
- 查看当前隔离级别：
  ```sql
  SELECT @@transaction_isolation;
  ```

## **总结**
MySQL事务隔离机制通过**隔离级别+MVCC+锁**平衡一致性与性能。默认可重复读级别在保证数据一致性的同时，通过间隙锁和快照读实现高效并发。开发中需根据业务需求选择隔离级别：高并发OLTP推荐读已提交，强一致性场景用可重复读，金融核销等极端场景用串行化。需注意锁竞争和死锁问题，合理设计索引和事务粒度以优化性能。