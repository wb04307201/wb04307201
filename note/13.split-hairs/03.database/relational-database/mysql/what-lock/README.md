在MySQL中，执行 `SELECT * FROM table WHERE id = ? FOR UPDATE` 语句时，**InnoDB存储引擎会为符合条件的行（或间隙）加** **排他锁（X锁，Exclusive Lock）**，具体锁行为需结合事务隔离级别、索引使用情况及查询条件综合分析：

### 1. **锁类型与特性**
- **排他锁（X锁）**：
    - 阻止其他事务对锁定行进行**修改（UPDATE/DELETE）**或**加共享锁（S锁，如`FOR SHARE`）**，但允许其他事务**读取**（需等待锁释放）。
    - 锁持有直至当前事务结束（提交或回滚）。
- **行级锁**：
    - 若`WHERE id = ?`中的`id`是**主键或唯一索引**，锁会精确到目标行（Record Lock）。
    - 若`id`非索引或为普通索引，可能触发**间隙锁（Gap Lock）**，锁定范围（如`id > 10`会锁住10到下一个存在的id之间的间隙），防止其他事务插入满足条件的新行。
    - 若无索引，可能退化为**表级锁**（极端情况，性能差）。

### 2. **锁行为关键因素**
- **事务隔离级别**：
    - **读已提交（READ COMMITTED）**：仅锁定符合条件的行，不锁间隙。
    - **可重复读（REPEATABLE READ，默认）**：可能加间隙锁，防止幻读（如范围查询时）。
- **索引使用**：
    - 有索引时，锁精准到行；无索引时，锁可能扩散到表或范围。
- **WHERE条件**：
    - 等值查询（如`id=5`）锁单行；范围查询（如`id>5`）可能锁多行+间隙。

### 3. **典型场景示例**
假设表结构：
```sql
CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(50)
) ENGINE=InnoDB;
```

- **场景1**：`SELECT * FROM users WHERE id=1 FOR UPDATE`
    - **锁行为**：对`id=1`的行加排他锁，其他事务无法修改/删除该行，但可读。
- **场景2**：`SELECT * FROM users WHERE id>10 FOR UPDATE`
    - **锁行为**：在可重复读隔离级别下，锁住所有`id>10`的行及间隙（如10到下一个存在的id之间），防止新插入`id>10`的行。

### 4. **注意事项**
- **死锁风险**：多事务同时锁定不同行时，可能因循环等待锁导致死锁，需设计事务逻辑避免。
- **性能影响**：锁范围过大（如间隙锁）或锁持有时间过长会阻塞其他事务，降低并发性能。
- **正确使用事务**：确保在业务逻辑完成后及时提交或回滚事务，释放锁。

### 5. **验证锁行为的方法**
- 使用`SHOW ENGINE INNODB STATUS`查看锁信息。
- 查询`information_schema.INNODB_LOCKS`和`INNODB_LOCK_WAITS`表监控锁状态。

**总结**：`FOR UPDATE`主要加排他锁，具体锁粒度（行/间隙/表）取决于索引、隔离级别和查询条件。设计高并发系统时，需合理使用索引、控制事务范围，并关注锁行为对性能的影响。