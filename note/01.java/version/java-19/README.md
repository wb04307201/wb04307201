# Java 19

- JEP 405：Record模式（预览）：Java 19 新特性—Record模式
- JEP 422：JDK移植到Linux/RISC-V
- JEP 424：外部函数和内存API（预览）
- JEP 425：虚拟线程（预览）：Java 19 新特性—虚拟线程
- JEP 426：向量API（第四次孵化）
- JEP 427：模式匹配的 Switch（第三次预览）
- JEP 428：结构化并发（孵化功能）

## JEP 405：Record模式（预览）
Java 14 引入预览特性 Record 旨在提供一种简洁的语法来声明类似数据的小型不可变对象，主要是为了解决长期以来在 Java 中定义纯数据载体类时，代码过于繁琐的问题。在 Java 16 中转为正式特性。

`instanceof`模式匹配也是在 Java 14 作为预览特性引入的，主要是为了解决`instanceof`在做类型匹配时需要进行强制类型转换而导致的代码冗余。

Java 19 引入 Record 模式作为预览特性，它允许在`instanceof`操作中使用记录模式，直接解构和匹配记录中的字段。

比如有一个记录`Record Point(int x, int y)`，可以使用 Record 模式直接检查和提取`x`和`y`值：
```java
if (obj instanceof Point(int x, int y)) {
    System.out.println(x+y);
}
```

## JEP 422：JDK移植到Linux/RISC-V
RISC-V 是一个开源的基于 RISC 的指令集架构。通过Linux/RISC-V移植，Java将获得对硬件指令集的支持。目前该端口支持以下的HotSpot VM选项：
- 模板解释器
- 客户端JIT编译器
- 服务端JIT编译器
- 包括ZGC和Shenandoah在内的主流垃圾收集器

该特性通过为 Linux/RISC-V 提供支持，增强了 Java 在多种硬件平台上的可用性和适应性。


## JEP 424：外部函数和内存API（预览）
外部函数和内存API 是 Java 17 作为预览特性引入的，它的核心在于提供一种安全、高效的方法来访问本地代码（例如 C 或 C++ 库）和内存。主要是通过两个组件实现的：
- **Foreign Function Interface (FFI)**: 允许 Java 代码直接调用非 Java 代码，特别是用 C/C++ 编写的代码。这可以通过定义一种类型安全的方式来实现，同时避免了 Java 本地接口（JNI）的复杂性和开销。
- **Foreign Memory Access API**：提供了一种安全的方法来访问不受 JVM 管理的内存。这对于需要操作系统级别内存操作或者直接与外部设备交互的应用程序非常重要。

| Java 版本  | 更新类型   | JEP      | 更新内容                   |
|----------|--------|----------|------------------------|
| Java 14	 | 孵化器	   | JEP 370	 | 引入了外部内存访问 API          |
| Java 15	 | 第二孵化器	 | JEP 383	 | 优化外部内存访问 API           |
| Java 16	 | 孵化器	   | JEP 389	 | 引入了外部链接器 API           |
| Java 16	 | 第三孵化器	 | JEP 393	 | 继续优化                   |
| Java 17	 | 孵化器	   | JEP 412	 | 引入了外部函数和内存 API         |
| Java 18	 | 二次孵化器	 | JEP 419	 | 在此版本中，API再次进行了一些改进和扩展。 |
| Java 19	 | 第一次预览	 | JEP 424  |                        |

## JEP 425：虚拟线程（预览）
虚拟线程是一种轻量级的线程，也就是我们俗称的协程。它的资源分配和调度由VM实现，而不是操作系统。虚拟线程的主要特点包括：
- **轻量级**：与传统线程相比，它更轻量，创建和销毁的成本较低。
- **简化并发编程**：由于不受操作系统线程数量的限制，我们可以为每个独立的任务创建一个虚拟线程，简化并发编程模型。

Java 19 引入虚拟线程的主要目的是为了解决以下问题：
- **解决并发编程复杂性**：传统的线程模型在处理大量并发任务时复杂且效率低下。虚拟线程简化了并发编程，因为它们更加轻量级，并且易于管理。
- **资源限制**：操作系统线程是有限的资源，大量线程的创建和管理可能会导致性能下降和资源耗尽。虚拟线程通过减轻这些限制，使得创建和管理大量线程成为可能。

## JEP 426：向量API（第四次孵化）
向量 API 是在 Java 16 中作为孵化器引入的，其目的是提供一个表达式丰富、编译时性能可预测的平台，用于编写复杂的向量计算，以充分利用现代处理器的 SIMD（单指令多数据）指令。

它经历了 Java 16 、Java 17 、Java 18 三次孵化，这是第四次孵化：

| Java 版本	 | 更新类型	  | JEP	     | 更新内容                                     |
|----------|--------|----------|------------------------------------------|
| Java 16	 | 第一次孵化	 | JEP 338	 | 提供了一个平台无关的方式来表达向量计算，能够充分利用现代处理器上的向量硬件指令。 |
| Java 17	 | 第二次孵化	 | JEP 414	 | 对 API 进行了改进，增加了性能优化和新的功能。                |
| Java 18	 | 第三次孵化	 | JEP 417	 | 进一步增强 API，改进了性能和易用性。                     |
| Java 19	 | 第四次孵化	 | JEP 426	 | 进一步增强 API。                               |

## JEP 427：模式匹配的 Switch（第三次预览）
模式匹配的 Switch 首次是在 Java 17 中作为预览特性引入，其主要目的是为了简化在case 标签中进行类型检查和类型转换，减少冗余的代码。

| Java 版本	 | 更新类型	  | JEP	     | 更新内容                      |
|----------|--------|----------|---------------------------|
| Java 17	 | 第一次预览	 | JEP 406	 | 引入了模式匹配的 Swith 表达式作为预览特性。 |
| Java 18	 | 第二次预览	 | JEP 420	 | 对其做了改进和细微调整               |
| Java 19	 | 第三次预览	 | JEP 427	 | 进一步优化模式匹配的 Swith 表达式。     |

## EP 428：结构化并发（孵化功能）
传统的并发编程模型往往让开发者面对复杂的线程管理和错误处理问题，尤其是在多线程和异步编程场景中。Java 19 引入结构化并发，其主要目的是为了改善 Java 并发模型，简化 Java 中的并发编程。

结构化并发是一种新的并发编程范式，旨在使并发操作更容易管理和维护。它通过引入一种称为“结构化并发”的概念来实现，该概念强调将并发任务组织在一起，使它们的生命周期更加清晰和可控。