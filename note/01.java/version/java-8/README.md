# Java 8

## JEP 126：Lambda 表达式
Lambda 表达式是 Java 8 新特性中最重要且最显著的一个，为 Java 增加了函数式编程的能力，使得代码变得更加简洁和易读。Lambda 表达式主要用于简化匿名内部类的实现。

Lambda 表达式的基本语法：

`(parameters) -> expression 或 (parameters) -> { statements; }`
- **parameters**：是 Lambda表达式的参数列表，可以为空或包含一个或多个参数。
- **->**：是 Lambda 操作符，用于将参数和 Lambda 主体分开。
- **expression**：是 Lambda 表达式的返回值，或者在主体中执行的单一表达式。
- **{ statements; }**：是 Lambda 主体，包含了一系列语句，如果需要执行多个操作，就需要使用这种形式。

它具有如下几个特点：
- **无需声明类型**：Lambda 表达式不需要声明参数类型，编译器可以自动推断参数类型。
- **可选的参数圆括号**：当只有一个参数时，可以省略圆括号。但是当参数个数大于一个时，圆括号是必需的。空括号用于表示空参数集。
- **可选的大括号**：当 Lambda 表达式的主体只包含一个表达式时，可以省略大括号。当表达式需要包含多个语句时，需要使用大括号。
- **可选的返回关键字**：当 Lambda 表达式主体只有一个表达式，且该表达式会自动返回结果时，可以省略 return 关键字。

## JEP 126：函数式接口
Java 8 引入函数式接口的主要目的是支持函数式编程范式，也就是 Lambda 表达式。在函数式编程语言中，函数被当做一等公民对待，Lambda 表达式的类型是函数，它可以像其他数据类型一样进行传递、赋值和操作。但是在 Java 中，“一切皆对象”是不可违背的宗旨，所以 Lambda 表达式是对象，而不是函数，他们必须要依附于一类特别的对象类型：函数式接口。所以函数式接口是与Lambda表达式紧密相连的，它为Java添加了一种新的抽象层次，允许将方法作为一等公民对待。

函数式接口具有两个特点：
- **只包含一个抽象方法**：函数式接口只能有一个抽象方法，但可以包含多个默认方法或静态方法。
- **用`@FunctionalInterface`注解标记**：该注解不强制，但通常会使用它来标记该接口为函数式接口。这样做可以让编译器检查接口是否符合函数式接口的定义，以避免不必要的错误。

一般来说函数式接口有两个最主要的用途：
- 与Lambda表达式一起使用，为Java带来更加函数式的编程风格。
- 用于实现简单的函数策略或行为，如回调、事件处理等。

## JEP 179：方法引用
为了提升 Java 编程语言的表达力和可读性，特别是在配合 Lambda 表达式和函数式编程风格，Java 8 引入方法引用。

方法引用实际上是一个简化版的 Lambda 表达式，它允许我们以更简洁的方式引用方法。它有如下几种类型：
- **静态方法引用**：使用 类名::静态方法名 的形式。  
  例如，String::valueOf 相当于 x -> String.valueOf(x)。
- **实例方法引用(对象的实例方法)**：使用 实例对象::实例方法名 的形式。  
  例如，假设有一个 String 对象 myString，那么 myString::length 相当于 () -> myString.length()。
- **特定类型的任意对象的实例方法引用**：使用 类名::实例方法名。  
  例如，String::length 相当于 str -> str.length()。这里不是调用特定对象的 length 方法，而是用于任意的 String 对象。
- **构造器引用**：使用 类名::new。  
  例如，ArrayList::new 相当于 () -> new ArrayList<>()。

## JEP 150：接口的默认方法
在 Java 8 之前，接口中可以申明方法和变量的，只不过变量必须是 public、static、final 的，方法必须是 public、abstract的。我们知道接口的设计是一项巨大的工作，因为如果我们需要在接口中新增一个方法，需要对它的所有实现类都进行修改，如果它的实现类比较少还可以接受，如果实现类比较多则工作量就比较大了。

为了解决这个问题，Java 8 引入了默认方法，默认方法允许在接口中添加具有默认实现的方法，它使得接口可以包含方法的实现，而不仅仅是抽象方法的定义。

默认方法是接口中带有 default 关键字的非抽象方法。这种方法可以有自己的实现，而不需要子类去覆盖它。

默认方法允许我们向接口添加新方法而不破坏现有的实现。它解决了在 Java 8 之前，向接口添加新方法意味着所有实现该接口的类都必须修改的问题。

## JEP 107：Stream API
为了解决 Java 8 之前版本中集合操作的一些限制和不足，提高数据处理的效率和代码的简洁性，Java 8 引入 Stream API，它的引入标志着 Java 对集合操作迎来了的一种全新的处理方式，它在处理集合类时提供了一种更高效、声明式的方法。

Stream API的核心思想是将数据处理操作以函数式的方式链式连接，以便于执行各种操作，如过滤、映射、排序、归约等，而无需显式编写传统的循环代码。

下面是 Stream API 的一些重要概念和操作：

- **Stream(流)**：Stream 是 Java 8 中处理集合的关键抽象概念，它是数据渠道，用于操作数据源所生成的元素序列。这些数据源可以来自集合（Collection）、数组、I/O 操作等等。它具有如下几个特点：
  1. Stream 不会存储数据。 
  2. Stream 不会改变源数据对象，它返回一个持有结果的新的 Stream。 
  3. Stream 操作是延迟执行的，这就意味着他们要等到需要结果的时候才会去执行。
- **中间操作**：这些操作允许您在 Stream 上执行一系列的数据处理。常见的中间操作有 filter（过滤）、map（映射）、distinct（去重）、sorted（排序）、limit（截断）、skip（跳过）等。这些操作返回的仍然是一个 Stream。
- **终端操作**：终端操作是对流进行最终处理的操作。当调用终端操作时，流将被消费，不能再进行进一步的中间操作。常见的终端操作包括 forEach（遍历元素）、collect（将元素收集到集合中）、reduce（归约操作，如求和、求最大值）、count（计数）等。
- **惰性求值**：Stream 操作是惰性的，只有在调用终端操作时才会执行中间操作。这可以提高性能，因为只处理需要的数据。

## [Optional 类](optional%2FREADME.md)

