# 乐观锁和悲观锁

悲观锁和乐观锁是两种常见的并发控制机制，用于处理多线程或多进程环境中的数据访问冲突问题。它们在数据库系统、分布式系统和多线程编程中都有广泛应用

## 乐观锁
乐观锁（Optimistic Lock）是一种假设冲突不会频繁发生的锁机制。每次数据访问时，不会加锁，而是在更新数据时检查是否有其他线程修改过数据。如果检测到冲突（数据被其他线程修改过），则重试操作或报错。

乐观锁通常实现方式有以下两种：
- **版本号机制**：每次读取数据时，读取一个版本号，更新数据时，检查版本号是否变化，如果没有变化，则更新成功，否则重试。
- **时间戳机制**：类似版本号机制，通过时间戳来检测数据是否被修改。

### 应用场景
适用于读多写少的场景，例如用户评论系统、社交媒体点赞等，这些场景下并发冲突概率较低。

### 优缺点
- **优点**：避免了频繁的锁操作，性能较好，适合读多写少的场景。
- **缺点**：在高并发写操作的场景下，重试可能会频繁发生，导致性能下降。

## 悲观锁
悲观锁（Pessimistic Lock）是一种假设冲突会频繁发生的锁机制。每次数据访问时，都会先加锁，直到操作完成后才释放锁，这样可以确保在锁持有期间，其他线程无法访问这段数据，从而避免了并发冲突。

悲观锁的实现通常有以下两种方式：
- **数据库**：在数据库中，悲观锁通常通过SQL语句实现，例如SELECT ... FOR UPDATE。
- **编程语言**：在编程语言中，悲观锁可以使用互斥锁（Mutex）或同步块（Synchronized Block）来实现。

### 应用场景
适用于对数据并发冲突非常敏感的场景，例如银行转账操作、库存扣减等需要严格数据一致性的操作。

### 优缺点
- **优点**：可以完全避免并发冲突，保证数据的一致性和完整性。
- **缺点**：由于每次访问数据都需要加锁和解锁，会导致性能开销较大，特别是在并发量高的情况下，容易造成锁竞争和死锁问题。