# 消息队列

消息队列看作是一个存放消息的容器，当需要使用消息的时候，直接从容器中取出消息使用。由于队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。

## 消息队列的组成
- **Broker**：消息服务器，作为server提供消息核心服务。
- **Producer**：消息生产者，业务的发起方，负责生产消息传输给broker。
- **Consumer**：消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理。
- **Topic**：主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的广播。
- **Queue**：队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收。
- **Message**：消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输。

## 使用消息队列会产生的问题
- **系统可用性降低**：系统可用性在某种程度上降低，在加入 MQ 之前，不用考虑消息丢失或者说 MQ 挂掉等等的情况
- **系统复杂性提高**：加入 MQ 之后需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等问题
- **一致性问题**：消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度，但是如果消息的真正消费者并没有正确消费消息

## JMS 和 AMQP

JMS（Java Message Service）和AMQP（Advanced Message Queuing Protocol）在消息队列和中间件领域都有重要的应用，但两者之间存在一些关键的区别。

### JMS

- **定义**：JMS是Java平台中关于面向消息中间件（MOM）的API，为分布式应用程序提供了一种异步通信的机制。
- **性质**：JMS是一个为Java平台设计的API，定义了统一的接口来对消息操作进行统一。

两种消息模型：
- Peer-2-Peer
- Pub/su

五种消息正文格式：
- **StreamMessage**：Java 原始值的数据流
- **MapMessage**：一套名称-值对
- **TextMessage**：一个字符串对象
- **ObjectMessage**：一个序列化的 Java 对象
- **BytesMessage**：一个字节的数据流

例如：ActiveMQ 就是基于 JMS 规范实现的。

### AMQP

- **定义**：AMQP是一个提供统一消息服务的应用层标准协议，为面向消息的中间件设计。
- **性质**：AMQP是一个跨语言、跨平台的高级消息队列协议，它定义了客户端与消息中间件之间传递消息的方式。

五种消息模型：
- direct exchange
- fanout exchange
- topic change
- headers exchange
- system exchange

消息正文格式：byte[]（二进制）

本质来讲，后四种和 JMS 的 pub/sub 模型没有太大差别，仅是在路由机制上做了更详细的划分

例如：RabbitMQ 就是基于 AMQP 协议实现的。

### 应用场景
- **JMS**：如果应用程序主要使用Java开发，并且需要标准的消息服务接口，那么JMS可能是一个更好的选择。
- **AMQP**：如果应用程序需要跨语言通信和更灵活的消息路由机制，那么AMQP可能更合适。

## RPC 和消息队列的区别

### 设计理念
- **RPC**：RPC的设计初衷是实现远程服务的透明调用，即让调用者感觉像是在调用本地服务一样。它隐藏了底层网络通信的复杂性，使得开发者可以更加专注于业务逻辑的实现。
- **消息队列**：消息队列的设计则更注重于解耦、异步通信和流量削峰。它通过在生产者和消费者之间引入一个中间节点（即消息队列），实现了消息的异步传递和缓冲，从而降低了系统的耦合度和提高了系统的可扩展性。
### 通信方式
- **RPC**：RPC采用双向直接网络通信的方式，即调用者直接与被调用者进行通信，无需经过中间节点。这种通信方式具有高效、实时的特点，但也可能因为网络延迟或故障而导致调用失败。
- **消息队列**：消息队列则采用单向引入中间载体的网络通信方式。生产者将消息发送到消息队列中，消费者从消息队列中接收消息。这种通信方式具有异步、解耦的特点，但也可能因为消息队列的故障而导致消息丢失或延迟。
### 处理模式
- **RPC**：RPC通常是一个同步的过程，即调用者会等待被调用者的响应结果。这种处理模式适用于需要立即返回结果的应用场景。
- **消息队列**：消息队列则是一个异步的过程，生产者发送消息后不会等待消费者的响应结果。消费者可以按照自己的节奏处理消息，从而实现了对系统负载的平滑处理。
### 应用场景
- **RPC**：RPC通常用于需要高效、实时通信的分布式系统中，如微服务架构中的服务间调用。它提供了像调用本地服务一样的体验，使得开发者可以更加便捷地实现服务间的协同工作。
- **消息队列**：消息队列则更适用于需要解耦、异步通信和流量削峰的应用场景。例如，在电商系统中，订单系统可以将订单信息发送到消息队列中，库存系统则可以从消息队列中接收订单信息并进行库存处理。这样，订单系统和库存系统之间就实现了松散的耦合关系，同时也可以通过消息队列来缓冲高峰期的订单流量。

## 应用场景

### 异步&解耦
![img.png](img.png)

### 消峰
![img_1.png](img_1.png)

### 消息总线
![img_2.png](img_2.png)

### 延时任务
用户在美团 APP 下单，假如没有立即支付，进入订单详情会显示倒计时，如果超过支付时间，订单就会被自动取消

![img_3.png](img_3.png)

### 广播消费
![img_4.png](img_4.png)

#### 消息推送
专车的司机端推送机制

![img_5.png](img_5.png)

#### 缓存同步
高并发场景

![img_6.png](img_6.png)

### 分布式事务
1. 传统XA事务方案：性能不足

2. 基于普通消息方案：一致性保障困难  
![img_7.png](img_7.png)

3. 基于 RocketMQ 分布式事务消息：支持最终一致性  
![img_8.png](img_8.png)

### 数据中转枢纽
![img_9.png](img_9.png)