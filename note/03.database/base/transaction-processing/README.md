# 事务处理

## 事务处理的四个特性ACID

![img.png](img.png)

![img_1.png](img_1.png)

### Atomicity原子性

![img_2.png](img_2.png)

### Consistency一致性

![img_3.png](img_3.png)

### lsolation隔离性

> 事务可以并发操作，这里就有一些问题：一个事务在写数据的时候，另一个事务要读这行数据，该怎么处理？一个事务在写数据，另一个数据也要写这行数据，又该怎么处理这个冲突？  
> 这就是并发事务所产生的一些问题。具体来说就是：脏读、丢失修改、不可重复读和幻读。  
> 这些问题的出现是由于数据库系统必须在并发控制（确保数据一致性）和性能（允许多个事务同时运行）之间进行权衡。  
> 为了解决这些问题，数据库系统提供了不同的事务隔离级别，每个级别对并发控制和性能的权衡有不同的偏好。在实际应用中，需要根据具体情况选择合适的隔离级别。

#### 脏读（Dirty read）
> 脏读是指一个事务读取了另一个未提交事务的数据。这可能会导致数据不一致，因为读取的数据可能在稍后被修改或者回滚。

![img_4.png](img_4.png)

![img_5.png](img_5.png)

#### 丢失修改（Lost to modify）
> 丢失修改是指两个或多个事务并发更新同一数据时，后一个事务的更新覆盖了前一个事务的更新。

![img_6.png](img_6.png)

#### 不可重复读（Unrepeatable read）
> 不可重复读是指在一个事务内，多次读取同一数据返回的结果有所不同。这是因为其他事务在这两次读取的过程中修改或删除了这些数据，导致第一次和第二次读取的数据不一致。

![img_7.png](img_7.png)

#### 幻读（Phantom read）
> 幻读是指在一个事务内，执行两次相同的查询，但返回的记录数不同。这是因为其他事务在这两次查询之间插入或删除了一些记录。这里区别不可重复读，一个是记录数一个是结果。

![img_8.png](img_8.png)

![img_9.png](img_9.png)

#### 事务隔离级别

![img_10.png](img_10.png)

> - **READ-UNCOMMITTED(读取未提交)**：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
> - **READ-COMMITTED(读取已提交)**：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
> - **REPEATABLE-READ(可重复读)**：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
> - **SERIALIZABLE(可串行化)**：最高的隔离级别，完全服从`ACID`的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

| 事务隔离级别                  | 脏读   | 不可重复读 | 幻读          |
|-------------------------|------|-------|-------------|
| READ-UNCOMMITTED(读取未提交) | 可能发生 | 可能发生  | 可能发生        |
| READ-COMMITTED(读取已提交)   | √    | 可能发生  | 可能发生        |
| REPEATABLE-READ(可重复读)   | √    | √     | 使用锁的情况下可以解决 |
| SERIALIZABLE(可串行化)      | √    | √     | √           |

### Durability持久性

![img_11.png](img_11.png)

## 并发事务的控制方式

### [锁](lock%2FREADME.md)

### [MVCC](mvcc%2FREADME.md)
