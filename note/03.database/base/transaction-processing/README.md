# 事务处理

## 事务处理的四个特性ACID

![img.png](img.png)

![img_1.png](img_1.png)

### Atomicity原子性

![img_2.png](img_2.png)

### Consistency一致性

![img_3.png](img_3.png)

### lsolation隔离性

![img_5.png](img_5.png)

事务是可以并发操作，这里就有一些问题：一个事务在写数据的时候，另一个事务要读这行数据，该怎么处理？一个事务在写数据，另一个数据也要写这行数据，又该怎么处理这个冲突？  
这就是并发事务所产生的一些问题。具体来说就是：脏读、丢失修改、不可重复读和幻读。  
这些问题的出现是由于数据库系统必须在并发控制（确保数据一致性）和性能（允许多个事务同时运行）之间进行权衡。  
为了解决这些问题，数据库系统提供了不同的事务隔离级别，每个级别对并发控制和性能的权衡有不同的偏好。在实际应用中，需要根据具体情况选择合适的隔离级别。

#### 脏读（Dirty read）
脏读是指一个事务读取了另一个未提交事务的数据。这可能会导致数据不一致，因为读取的数据可能在稍后被修改或者回滚。

![img_4.png](img_4.png)

#### 丢失修改（Lost to modify）
丢失修改是指两个或多个事务并发更新同一数据时，后一个事务的更新覆盖了前一个事务的更新。

![img_6.png](img_6.png)

#### 不可重复读（Unrepeatable read）
不可重复读是指在一个事务内，多次读取同一数据返回的结果有所不同。这是因为其他事务在这两次读取的过程中修改或删除了这些数据，导致第一次和第二次读取的数据不一致。

![img_7.png](img_7.png)

#### 幻读（Phantom read）
幻读是指在一个事务内，执行两次相同的查询，但返回的记录数不同。这是因为其他事务在这两次查询之间插入或删除了一些记录。这里区别不可重复读，一个是记录数一个是结果。

![img_8.png](img_8.png)

#### 事务隔离级别

![img_10.png](img_10.png)

- **READ-UNCOMMITTED(读取未提交)**：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
- **READ-COMMITTED(读取已提交)**：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
- **REPEATABLE-READ(可重复读)**：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
- **SERIALIZABLE(可串行化)**：最高的隔离级别，完全服从`ACID`的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

| 事务隔离级别                  | 脏读   | 不可重复读 | 幻读          |
|-------------------------|------|-------|-------------|
| READ-UNCOMMITTED(读取未提交) | 可能发生 | 可能发生  | 可能发生        |
| READ-COMMITTED(读取已提交)   | √    | 可能发生  | 可能发生        |
| REPEATABLE-READ(可重复读)   | √    | √     | 使用锁的情况下可以解决 |
| SERIALIZABLE(可串行化)      | √    | √     | √           |

### Durability持久性

![img_11.png](img_11.png)

## 并发事务的控制方式
悲观锁和乐观锁是两种常见的并发控制机制，用于处理多线程或多进程环境中的数据访问冲突问题。  
它们在数据库系统、分布式系统和多线程编程中都有广泛应用。
数据库锁是一种常见的悲观锁  
MVCC是一种常见的乐观锁

### [数据库锁](lock%2FREADME.md)

### [MVCC](mvcc%2FREADME.md)

### MVCC与锁的关系
#### 目的不同但相辅相成
- **MVCC**：主要通过维护数据的多个版本来实现并发控制，旨在提高数据库的并发性能，允许读写操作同时进行，减少锁竞争。
- **锁**：通过锁定数据资源来避免并发操作中的冲突，保证数据的一致性和完整性。锁机制包括悲观锁和乐观锁，悲观锁在数据处理前加锁，乐观锁则通过版本号或时间戳等方式在数据处理过程中检查冲突。
#### 实现方式不同
- **MVCC**：在`InnoDB`等存储引擎中，MVCC通过维护数据的多个版本来实现。当事务对数据进行修改时，旧的数据版本会被保存在Undo日志中，同时为新的事务生成新的数据版本。这样，不同的事务可以根据需要读取不同版本的数据，从而实现非阻塞的并发访问。
- **锁**：则通过直接锁定数据资源来避免冲突。悲观锁在数据处理前加锁，阻止其他事务对同一资源的访问；乐观锁则在数据处理过程中通过版本号或时间戳等方式来检查是否存在冲突。
#### 应用场景不同
- **MVCC**：更适用于读多写少的场景，因为它能够显著提高数据库的并发性能，减少锁竞争。
- **锁**：则适用于写操作较多的场景，因为它能够直接锁定资源，防止数据在并发修改时出现冲突。
