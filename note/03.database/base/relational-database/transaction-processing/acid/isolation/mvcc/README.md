# 多版本并发控制

数据库多版本并发控制（MVCC，Multiversion Concurrency Control）是一种用于管理数据库并发访问的核心机制，旨在通过维护数据的历史版本来协调读写操作，从而提升并发性能并保证事务隔离性。以下是其关键要点：

### **核心思想**
- **版本化数据**：每次修改数据时（如UPDATE或DELETE），MVCC不会直接覆盖原有数据，而是创建新版本，并通过指针（如回滚指针）链接旧版本，形成版本链。
- **事务隔离**：每个事务只能看到其开始前提交的数据版本或自身修改的版本，避免读取未提交或冲突的数据。
- **非阻塞读**：读操作（快照读）无需加锁，通过版本筛选直接访问历史版本，写操作（当前读）则通过锁机制保证一致性。

### **实现机制（以InnoDB为例）**
1. **隐藏列**：
    - `DATA_TRX_ID`：记录最后修改该行的事务ID。
    - `DATA_ROLL_PTR`：回滚指针，指向Undo Log中的历史版本。
    - `DELETE BIT`：标记行是否被删除（真正删除需等待垃圾回收）。

2. **版本链与Undo Log**：
    - 每次修改时，旧版本数据被移至Undo Log，新记录指向旧版本。
    - 读操作通过遍历版本链找到符合可见性规则的版本。

3. **可见性判断**：
    - 事务启动时创建Read View（包含活跃事务ID列表），根据以下规则判断数据版本是否可见：
        - 版本事务ID ≤ 当前事务ID且未在活跃事务列表中 → 可见。
        - 版本事务ID > 当前事务ID → 不可见（需回溯Undo Log）。
    - 例如，在`REPEATABLE READ`隔离级别下，Read View在事务开始时固定，避免幻读。

4. **操作处理**：
    - **INSERT**：新行标记当前事务ID。
    - **DELETE**：仅标记删除位（事务提交后真正删除）。
    - **UPDATE**：复制新版本并标记旧版本为删除。

### **优势与缺点**
- **优势**：
    - **高并发**：读写不阻塞，提升吞吐量。
    - **隔离性**：避免脏读、不可重复读（需结合锁机制解决幻读）。
    - **历史查询**：支持时间点一致性读。
- **缺点**：
    - **存储开销**：需维护多版本数据。
    - **垃圾回收**：需定期清理旧版本（如InnoDB的purge操作）。
    - **复杂性**：实现和维护成本较高。

### **应用场景**
- **数据库引擎**：广泛应用于MySQL（InnoDB）、PostgreSQL、Oracle等。
- **隔离级别**：主要支持`READ COMMITTED`和`REPEATABLE READ`（`SERIALIZABLE`需加锁）。
- **适用场景**：高并发OLTP系统、需要非阻塞读的业务（如电商订单查询、实时数据分析）。

### **与其他机制的结合**
- **锁机制**：MVCC处理快照读，当前读（如`SELECT ... FOR UPDATE`）仍需加锁。
- **两阶段锁（2PL）**：部分数据库（如PostgreSQL）结合MVCC与锁实现可串行化调度。

MVCC通过权衡存储空间与并发性能，成为现代数据库实现高效事务处理的关键技术。其具体实现因数据库而异（如PostgreSQL直接存储多版本，InnoDB依赖Undo Log），但核心目标均为通过版本管理减少竞争。