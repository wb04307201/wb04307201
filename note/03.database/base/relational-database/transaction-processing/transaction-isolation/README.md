# 事务隔离

数据库事务隔离级别是用于控制多个事务并发执行时相互干扰程度的机制，旨在平衡数据一致性与系统性能。国际标准ANSI/ISO定义了四个隔离级别，从低到高依次为：**读未提交（Read Uncommitted）**、**读已提交（Read Committed）**、**可重复读（Repeatable Read）**和**串行化（Serializable）**。每个级别通过限制事务间的交互行为，解决特定的并发问题（如脏读、不可重复读、幻读）。

## 1. 四个隔离级别的核心特性
- **读未提交（Read Uncommitted）**
    - **允许行为**：事务可读取其他未提交事务修改的数据（“脏读”）。
    - **解决的问题**：无（最低隔离级别）。
    - **并发问题**：脏读、不可重复读、幻读均可能发生。
    - **场景**：仅用于对数据一致性要求极低的场景（如临时统计），性能最高但风险最大。

- **读已提交（Read Committed）**（多数数据库默认级别）
    - **允许行为**：事务只能读取已提交的数据，但其他事务的修改（如UPDATE）在提交后对本事务可见。
    - **解决的问题**：脏读。
    - **并发问题**：不可重复读（同一事务内多次读取同一行结果不同）、幻读（同一事务内多次查询范围行数不同）仍可能发生。
    - **实现**：通过“行锁”或“数据版本”控制，确保读取时跳过未提交数据。

- **可重复读（Repeatable Read）**（如MySQL默认）
    - **允许行为**：同一事务内多次读取同一数据范围时，结果保持一致（基于事务开始时的快照）。
    - **解决的问题**：脏读、不可重复读。
    - **并发问题**：幻读可能发生（取决于数据库实现）。例如，MySQL通过MVCC（多版本并发控制）在可重复读级别下避免幻读；而SQL Server在该级别下仍可能遇到幻读。
    - **实现**：MVCC（如InnoDB）为事务生成数据快照，或使用“范围锁”锁定查询条件。

- **串行化（Serializable）**（最高隔离级别）
    - **允许行为**：事务串行执行，完全避免并发问题。
    - **解决的问题**：脏读、不可重复读、幻读。
    - **实现**：通过锁协议（如表级锁）或时间戳排序强制事务顺序执行，性能最低但安全性最高。

| 事务隔离级别                  | 脏读   | 不可重复读 | 幻读          |
|-------------------------|------|-------|-------------|
| READ-UNCOMMITTED(读取未提交) | 可能发生 | 可能发生  | 可能发生        |
| READ-COMMITTED(读取已提交)   | √    | 可能发生  | 可能发生        |
| REPEATABLE-READ(可重复读)   | √    | √     | 使用锁的情况下可以解决 |
| SERIALIZABLE(可串行化)      | √    | √     | √           |

## 2. 并发问题定义与示例
- **脏读（Dirty Read）**：事务A读取事务B未提交的数据，若B回滚，A读取的数据无效。
    - 示例：A读B未提交的转账记录，误认为余额已增加。
- **不可重复读（Non-repeatable Read）**：事务A两次读取同一行数据，结果不同（因其他事务提交修改）。
    - 示例：A先读用户余额为100，B更新为200并提交，A再次读取得200。
- **幻读（Phantom Read）**：事务A两次查询同一范围，结果行数不同（因其他事务插入/删除）。
    - 示例：A统计用户表得10条记录，B插入1条并提交，A再次查询得11条。

## 3. 数据库实现差异
- **MySQL（InnoDB）**：
    - 默认隔离级别为可重复读，通过MVCC+间隙锁（Gap Lock）避免幻读。
    - 读已提交级别下，MVCC确保读取最新已提交数据，但不可重复读仍可能发生。
- **Oracle**：
    - 默认隔离级别为读已提交，通过“数据版本+撤销日志”实现，可重复读需显式设置且依赖锁机制。
    - 串行化级别通过“可序列化事务”模式实现，性能损耗较大。
- **PostgreSQL**：
    - 默认读已提交，可重复读级别下通过MVCC避免幻读，串行化使用谓词锁（Predicate Lock）或乐观锁。

## 4. 隔离级别选择策略
- **性能与一致性权衡**：高并发场景优先选择读已提交（平衡性能与数据一致性），强一致性要求（如金融交易）选择可重复读或串行化。
- **数据库特性适配**：根据数据库默认级别及实现机制（如MVCC、锁类型）调整，避免过度隔离导致性能下降。
- **应用层控制**：通过业务逻辑（如版本号、状态机）补充隔离级别不足，例如在可重复读下手动校验数据版本。

**总结**：事务隔离级别是数据库并发控制的核心，理解其原理、问题及实现差异，是设计高并发、高一致性系统的关键。选择时需结合业务需求、数据库特性及性能要求，避免盲目追求高隔离级别导致资源浪费，或低级别引发数据错误。