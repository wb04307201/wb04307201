# MySQL锁类型详解

MySQL的锁机制是保障数据一致性和事务隔离的核心设计，不同存储引擎（如InnoDB、MyISAM）的锁粒度、类型及适用场景差异显著。

## 1. 全局锁（Global Lock）
- **定义**：通过`FLUSH TABLES WITH READ LOCK`（FTWRL）命令对整个数据库实例加锁，使数据库进入**只读状态**。
- **作用场景**：主要用于全库逻辑备份（如mysqldump），确保备份期间数据不被修改，避免数据不一致。
- **锁粒度与影响**：
    - 锁住所有表，阻塞所有写操作（INSERT/UPDATE/DELETE）及结构变更（ALTER TABLE等）。
    - 备份完成后需手动释放（执行`UNLOCK TABLES`）。
- **替代方案**：在支持事务的存储引擎（如InnoDB）中，推荐使用**可重复读隔离级别**下的`mysqldump --single-transaction`，通过MVCC（多版本并发控制）实现无锁备份。

## 2. 表级锁（Table-Level Locking）
- **显式表锁**：
    - **读锁（READ LOCK）**：`LOCK TABLES t READ`，允许其他事务读同一表，但阻塞写操作。
    - **写锁（WRITE LOCK）**：`LOCK TABLES t WRITE`，独占表访问，阻塞其他所有读写操作。
- **隐式表锁**：
    - **DDL操作**：如`ALTER TABLE`会隐式加排他表锁，阻塞其他所有操作。
    - **MyISAM引擎**：默认支持表级锁，写操作会阻塞所有读/写，读操作仅阻塞写操作（读写冲突）。
- **锁粒度与并发**：
    - 锁粒度大，并发性能低，适合非高并发场景或MyISAM引擎。
    - InnoDB引擎在表级锁之外，更依赖行级锁实现高并发。

## 3. 行级锁（Row-Level Locking，InnoDB核心）
- **记录锁（Record Lock）**：
    - 锁定索引记录（如主键、唯一索引），防止其他事务修改或删除该行。
    - 示例：`SELECT ... FOR UPDATE`会加排他记录锁。
- **间隙锁（Gap Lock）**：
    - 锁定索引记录之间的“间隙”（如范围查询），防止其他事务插入新记录，避免幻读。
    - 示例：在可重复读隔离级别下，`WHERE id BETWEEN 10 AND 20`会锁定10到20的间隙。
- **临键锁（Next-Key Lock）**：
    - 记录锁+间隙锁的组合，锁定记录本身及前后的间隙，是InnoDB默认的行锁实现。
- **共享锁（S锁/读锁）与排他锁（X锁/写锁）**：
    - **S锁**：允许读，但阻塞写（多个事务可同时持S锁）。
    - **X锁**：独占写，阻塞其他所有读写（仅一个事务可持X锁）。
- **意向锁（Intention Lock）**：
    - **IS锁（意向共享）**：事务计划对表加S锁时，先在表级加IS锁。
    - **IX锁（意向排他）**：事务计划对表加X锁时，先在表级加IX锁。
    - 作用：协调表级锁与行级锁的兼容性（如表级锁需检查意向锁存在）。
- **自增锁（AUTO-INC Lock）**：
    - 插入自增主键时，对表加自增锁，确保自增值连续唯一（InnoDB在事务提交后释放）。

## 4. 元数据锁（Metadata Lock，MDL）
- **定义**：自动加锁机制，保护表结构（元数据）不被并发修改。
- **类型**：
    - **MDL读锁**：查询表结构时自动加（如`SHOW CREATE TABLE`），允许并发读，阻塞写。
    - **MDL写锁**：修改表结构时自动加（如`ALTER TABLE`），阻塞所有读写。
- **作用场景**：防止DDL（如改表结构）与DML（增删改查）冲突，避免数据字典不一致。
- **锁冲突案例**：长事务持有MDL读锁未释放，可能导致后续DDL操作被阻塞，引发数据库“卡死”。

## 锁的兼容性与死锁处理
- **兼容性规则**：
    - S锁与S锁兼容，S锁与X锁、X锁与X锁互斥。
    - 意向锁（IS/IX）之间兼容，但与排他表锁（如`LOCK TABLES ... WRITE`）互斥。
- **死锁检测与处理**：
    - InnoDB通过**等待图（Wait-for Graph）** 自动检测死锁（如循环等待锁），回滚其中一个事务（牺牲较小的事务）以打破死锁。
    - 用户可通过`SHOW ENGINE INNODB STATUS`查看死锁日志。
- **锁优化策略**：
    - 尽量使用行级锁（如InnoDB），减少锁冲突。
    - 避免长事务，减少锁持有时间。
    - 合理设计索引，使查询锁定更少的行（如避免全表扫描）。
    - 使用乐观锁（如版本号）或悲观锁（`SELECT ... FOR UPDATE`）根据业务需求选择。

## 存储引擎差异
- **InnoDB**：支持行级锁、MVCC、事务，高并发场景首选。
- **MyISAM**：仅支持表级锁，无事务，适合读多写少、非高并发场景。
- **NDB**：集群引擎，支持行级锁，但应用场景较少。

## 锁监控与诊断
- **监控工具**：
    - `SHOW PROCESSLIST`：查看当前线程及锁等待。
    - `information_schema.INNODB_TRX`：查看活跃事务及锁信息。
    - `performance_schema`：监控锁等待、死锁等事件。
- **关键指标**：`Innodb_row_lock_waits`（行锁等待次数）、`Innodb_row_lock_time`（行锁等待总时间）。

**总结**：MySQL锁机制需结合业务场景（如高并发、事务隔离需求）选择存储引擎及锁类型。InnoDB的行级锁+MVCC是高并发场景的黄金组合，但需警惕间隙锁导致的死锁或锁竞争；表级锁适合低并发或结构变更场景；全局锁和MDL锁则保障数据一致性及元数据安全。合理设计索引、控制事务粒度、监控锁状态是优化锁性能的关键。