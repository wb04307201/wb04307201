# 时间类型对比

## 1. 核心时间类型对比
| **类型**        | **存储格式**              | **存储范围**                                            | **存储空间** | **时区处理**              | **自动更新**                                                    | **适用场景**                 |
|---------------|-----------------------|-----------------------------------------------------|----------|-----------------------|-------------------------------------------------------------|--------------------------|
| **DATE**      | `YYYY-MM-DD`          | `1000-01-01`到`9999-12-31`                           | 3字节      | 无时区信息                 | 不支持                                                         | 仅需日期的场景（如生日、节假日）         |
| **TIME**      | `HH:MM:SS`            | `-838:59:59`到`838:59:59`                            | 3字节      | 无时区信息                 | 不支持                                                         | 具体时间点（如会议开始时间、时长）        |
| **DATETIME**  | `YYYY-MM-DD HH:MM:SS` | `1000-01-01 00:00:00`到`9999-12-31 23:59:59`         | 8字节      | 固定存储，无时区转换            | 需手动设置或触发器实现                                                 | 历史记录、未来日期（如订单创建时间、跨世纪数据） |
| **TIMESTAMP** | `YYYY-MM-DD HH:MM:SS` | `1970-01-01 00:00:01` UTC到`2038-01-19 03:14:07` UTC | 4字节      | 自动转换为UTC存储，检索时按会话时区转换 | 支持`DEFAULT CURRENT_TIMESTAMP`和`ON UPDATE CURRENT_TIMESTAMP` | 需时区同步的场景（如日志、跨时区应用）      |
| **YEAR**      | `YYYY`                | `1901`到`2155`                                       | 1字节      | 无时区信息                 | 不支持                                                         | 仅需年份的场景（如出生年份、年度统计）      |

## 2. 关键差异解析
- **时区处理**：
    - **TIMESTAMP**：存储时转为UTC，检索时根据`@@session.time_zone`（会话时区）或`@@global.time_zone`（全局时区）转换。例如，北京时间（UTC+8）插入后，在东京时区（UTC+9）查询会显示+1小时。
    - **DATETIME**：直接存储原始值，不受时区影响，适合固定时间点（如合同签署时间）。

- **存储与性能**：
    - **TIMESTAMP**占用4字节，是DATETIME的一半，但范围受限（至2038年），适合短期或近期数据。
    - **DATETIME**占用8字节，支持更广范围（至9999年），适合长期历史数据或未来日期。

- **自动更新**：
    - **TIMESTAMP**可通过`DEFAULT CURRENT_TIMESTAMP`和`ON UPDATE CURRENT_TIMESTAMP`实现插入/更新时自动记录时间戳，常用于记录创建和修改时间。
    - **DATETIME**需手动设置或通过触发器实现类似功能。

## 3. 选择建议
- **优先TIMESTAMP的场景**：
    - 跨时区应用（如国际化系统、日志记录）。
    - 需自动更新时间戳的场景（如用户最后登录时间）。
    - 存储空间敏感的场景（如大规模日志表）。

- **优先DATETIME的场景**：
    - 需存储历史或未来日期（如出生日期、预约时间）。
    - 时区无关的固定时间点（如财务报表日期）。
    - 避免2038年问题的长期数据。

- **其他类型选择**：
    - **DATE**：仅需日期时（如生日、节假日）。
    - **TIME**：仅需时间时（如课程表、营业时间）。
    - **YEAR**：仅需年份时（如年度统计、成立年份）。

## 4. 实践避坑指南
- **时区配置**：
    - 全局时区通过`my.cnf`配置`default_time_zone='+08:00'`，会话时区用`SET time_zone='Asia/Shanghai'`动态调整。
    - 跨时区查询使用`CONVERT_TZ(time, '+00:00', '+08:00')`转换。

- **范围与有效性**：
    - 避免`0000-00-00`等无效日期，设置`sql_mode='NO_ZERO_IN_DATE,NO_ZERO_DATE'`。
    - 超出TIMESTAMP范围（如2038年后）必须用DATETIME。

- **索引优化**：
    - 时间范围查询（如`BETWEEN`）优先使用索引，避免在时间列上使用函数（如`YEAR(created_at)`）导致索引失效。

通过合理选择时间类型，结合时区配置和自动更新策略，可确保数据一致性、存储效率及查询性能，适配多样化业务需求。