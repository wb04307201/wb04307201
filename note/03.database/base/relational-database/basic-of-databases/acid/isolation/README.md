# 隔离性（Isolation）

隔离性是数据库事务**ACID**（原子性、一致性、隔离性、持久性）四大特性中的一个，它指的是**一个事务的执行不能被其他事务干扰**。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

---

## 1. 为什么需要隔离性？（并发问题）

如果没有隔离性，多个事务同时操作数据库时，可能会引发一系列问题：

*   **脏读**：一个事务读取到了另一个事务**尚未提交**的数据。
    *   **例子**：事务A将余额从100改为200（但未提交），事务B此时读取余额为200。之后事务A回滚，余额恢复为100，但事务B已经使用了错误的“200”这个数据。
*   **不可重复读**：一个事务内，多次读取同一数据，在读取过程中，另一个事务**修改并提交**了该数据，导致多次读取结果不一致。
    *   **例子**：事务A读取余额为100。此时事务B将余额改为200并提交。事务A再次读取余额，发现变成了200，与第一次读取不一致。
*   **幻读**：一个事务内，多次执行相同的查询，在查询过程中，另一个事务**插入或删除**了数据并提交，导致返回了不同的“幻影”行集合。
    *   **例子**：事务A查询“年龄大于30的用户”，得到10条记录。此时事务B插入了一条年龄为35的新用户并提交。事务A再次查询，得到了11条记录，仿佛出现了“幻觉”。

---

## 2. 解决方案：事务隔离级别

为了解决上述问题，SQL标准定义了四种事务隔离级别。隔离级别从低到高，对应的并发问题依次被解决，但系统的开销（性能）也随之增加。

| 隔离级别                       | 脏读 | 不可重复读 | 幻读 | 说明            |
|:---------------------------|:--:|:-----:|:--:|:--------------|
| **读未提交(READ-UNCOMMITTED)** | ❌  |   ❌   | ❌  | 性能最高，但问题最多    |
| **读已提交(READ-COMMITTED)**   | ✅  |   ❌   | ❌  | 只能读到已提交的数据    |
| **可重复读(REPEATABLE-READ)**  | ✅  |   ✅   | ❌  | 同一事务中多次读取结果一致 |
| **串行化(SERIALIZABLE)**      | ✅  |   ✅   | ✅  | 性能最低，但最安全     |

下面我们详细解释每个级别：

### a. 读未提交
*   **定义**：一个事务可以读取到另一个事务**未提交**的数据修改。
*   **现象**：会发生**脏读**、**不可重复读**、**幻读**。
*   **适用场景**：几乎不用，对数据一致性要求极低，且能容忍大量错误。

### b. 读已提交
*   **定义**：一个事务只能读取到另一个事务**已经提交**的数据修改。这是**大多数数据库系统的默认隔离级别**（如Oracle, SQL Server, PostgreSQL）。
*   **现象**：解决了**脏读**问题，但仍会发生**不可重复读**和**幻读**。
*   **工作原理**：通常通过**行级锁**实现。当事务修改某行时，会对该行加锁，直到事务提交或回滚后才释放锁。其他事务无法读取该行未提交的数据。

### c. 可重复读
*   **定义**：保证在同一个事务中，多次读取同一数据的结果是**一致**的。
*   **现象**：解决了**脏读**和**不可重复读**问题，但**幻读**问题在标准SQL中仍然可能发生（不过MySQL的InnoDB引擎通过Next-Key Lock机制在一定程度上避免了幻读）。
*   **工作原理**：通常通过**多版本并发控制**实现。事务开始时，会创建一个数据快照，整个事务期间都基于这个快照读取，从而看到一致的数据视图。
*   **适用场景**：需要在一个事务内多次读取相同数据且要求一致的场景。

### d. 串行化
*   **定义**：最高的隔离级别。它强制事务**串行执行**，而不是并发执行。事务会一个接一个地执行，每个事务在执行时都仿佛系统中没有其他事务在运行。
*   **现象**：解决所有并发问题（**脏读**、**不可重复读**、**幻读**）。
*   **代价**：性能开销巨大，并发度急剧下降，容易导致大量超时和锁争用。
*   **适用场景**：对数据一致性要求极高，且可以接受低性能的场景（如银行的核心账务系统）。

---

## 3. 实例说明

假设有一张`accounts`表，其中有一条记录：`balance = 100`。

| 时间 | 事务A                                             | 事务B                                        | 隔离级别下的现象                                                                                        |
|:---|:------------------------------------------------|:-------------------------------------------|:------------------------------------------------------------------------------------------------|
| T1 | `START TRANSACTION;`                            | `START TRANSACTION;`                       |                                                                                                 |
| T2 | `UPDATE accounts SET balance = 200 WHERE id=1;` |                                            |                                                                                                 |
| T3 |                                                 | `SELECT balance FROM accounts WHERE id=1;` | **读未提交**：读到200（脏读）<br>**读已提交**：读到100（因为A未提交）<br>**可重复读/串行化**：读到100                              |
| T4 | `COMMIT;`                                       |                                            |                                                                                                 |
| T5 |                                                 | `SELECT balance FROM accounts WHERE id=1;` | **读已提交**：读到200（不可重复读）<br>**可重复读**：仍然读到100（如果事务B的隔离级别是可重复读）<br>**串行化**：事务B必须等待事务A提交后才能执行，所以读到200 |

---

## 4. 如何选择隔离级别？

选择隔离级别是一个在**数据一致性**和**系统性能**之间的权衡。

*   **默认选择**：从**读已提交**开始。它避免了最严重的脏读问题，同时性能较好。
*   **需要可重复读**：如果你的业务需要在一个事务内多次读取相同数据并保证结果一致（例如，多次计算汇总值），则选择**可重复读**。
*   **需要绝对安全**：如果业务逻辑非常复杂，对数据一致性有极端要求（例如，涉及大量金额的统计），并且可以接受性能损失，则使用**串行化**。
*   **避免使用**：尽量避免使用**读未提交**，除非你完全清楚其风险。

## 5. 各数据库的默认隔离级别

*   **MySQL (InnoDB)**： **可重复读**
*   **PostgreSQL**： **读已提交**
*   **Oracle**： **读已提交**
*   **SQL Server**： **读已提交**

**注意**：虽然标准是这样定义的，但不同数据库的实现可能有细微差别（如MySQL的可重复读级别通过MVCC避免了幻读）。在使用时，最好查阅具体数据库的官方文档。

## 总结

数据库隔离性通过不同的**隔离级别**来管理并发访问，以防止数据出现不一致。理解这些隔离级别及其解决的问题（脏读、不可重复读、幻读）是设计和开发高可靠性数据库应用的基础。在实际应用中，应根据业务需求选择最合适的隔离级别，在数据一致性和系统性能之间找到最佳平衡点。